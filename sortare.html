<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simulare ForÈ›Äƒ CentrifugÄƒ È™i EficienÈ›Äƒ Sortare</title>
  <!-- 
    ============================================================================
    APLICAÈšIA DE SIMULARE A FORÈšEI CENTRIFUGE È˜I EFICIENÈšEI SORTÄ‚RII MATERIALELOR
    ============================================================================
    
    AceastÄƒ aplicaÈ›ie implementeazÄƒ o simulare interactivÄƒ pentru analiza comportamentului
    particulelor de diferite materiale Ã®ntr-un mediu centrifugal, utilizatÄƒ pentru
    optimizarea proceselor de sortare Ã®n industria minierÄƒ È™i metalurgicÄƒ.
    
    AUTOR: [Numele studentului]
    INSTITUÈšIA: [Numele universitÄƒÈ›ii]
    ANUL: [Anul academic]
    
    SCOPUL APLICAÈšIEI:
    - Simularea vizualÄƒ a forÈ›ei centrifuge asupra particulelor de materiale diverse
    - Calculul eficienÈ›ei de sortare faÈ›Äƒ de materialul steril (gangÄƒ)
    - Analiza comparativÄƒ a comportamentului materialelor Ã®n funcÈ›ie de densitate
    - Optimizarea parametrilor operaÈ›ionali (turaÈ›ia) pentru maximizarea eficienÈ›ei
    
    TEHNOLOGII UTILIZATE:
    - HTML5 Canvas pentru renderarea graficÄƒ Ã®n timp real
    - Chart.js pentru vizualizarea datelor statistice
    - CSS3 cu Grid Layout È™i Flexbox pentru interfaÈ›a responsivÄƒ
    - JavaScript ES6+ pentru logica de simulare È™i calcule fizice
  -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* 
    ============================================================================
    STILIZAREA CSS - DESIGN RESPONSIV CU LAYOUT LATERAL
    ============================================================================
    
    Sistemul de stilizare implementeazÄƒ un design modern cu sidebar lateral pentru
    controale È™i zonÄƒ principalÄƒ pentru simulare. UtilizeazÄƒ principiile de
    responsive design pentru adaptarea la diferite dimensiuni de ecran.
    */
    
    /* Layout principal cu Flexbox */
    body {
      font-family: 'Segoe UI', sans-serif;  /* Font modern pentru lizibilitate */
      background: #f4f6f9;                  /* Culoare de fundal neutrÄƒ */
      margin: 0;
      padding: 0;
      display: flex;                        /* Flexbox pentru layout lateral */
      min-height: 100vh;                    /* ÃŽnÄƒlÈ›ime minimÄƒ pe tot ecranul */
    }
    
    /* Sidebar-ul lateral pentru controale */
    .sidebar {
      width: 350px;                         /* LÄƒÈ›ime fixÄƒ pentru consistenÈ›Äƒ */
      background: white;                    /* Fundal alb pentru contrast */
      padding: 20px;                       /* SpaÈ›iere internÄƒ uniformÄƒ */
      border-right: 1px solid #ddd;        /* Separare vizualÄƒ de conÈ›inut */
      box-shadow: 2px 0 10px rgba(0,0,0,0.1); /* Efect de adÃ¢ncime */
      overflow-y: auto;                     /* Scroll vertical pentru conÈ›inut lung */
      position: fixed;                      /* PoziÈ›ie fixÄƒ pentru persistenÈ›Äƒ */
      height: 100vh;                       /* ÃŽnÄƒlÈ›ime completÄƒ pe verticalÄƒ */
      z-index: 1000;                       /* Prioritate de afiÈ™are */
    }
    
    .main-content {
      margin-left: 350px;
      padding: 20px;
      flex: 1;
      text-align: center;
    }
    
    .sidebar h3 {
      margin-bottom: 20px;
      color: #333;
      border-bottom: 2px solid #007bff;
      padding-bottom: 10px;
    }
    
    .control-group {
      margin-bottom: 25px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e9ecef;
    }
    
    .control-group h4 {
      margin: 0 0 15px 0;
      color: #495057;
      font-size: 14px;
      font-weight: 600;
    }
    
    .rpm-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .rpm-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .rpm-row label {
      min-width: 70px;
      font-size: 12px;
      color: #666;
    }
    
    .rpm-row input {
      flex: 1;
      min-width: 60px;
    }
    
    .sidebar input[type="range"] {
      width: 100%;
      margin: 10px 0;
    }
    
    .sidebar input[type="number"] {
      padding: 5px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .sidebar button {
      padding: 8px 12px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin: 5px 0;
    }
    
    .sidebar button:hover {
      background: #0056b3;
    }
    
    .sidebar button.reset {
      background: #28a745;
    }
    
    .sidebar button.reset:hover {
      background: #1e7e34;
    }
    
    @media (max-width: 1200px) {
      .sidebar {
        width: 300px;
      }
      .main-content {
        margin-left: 300px;
      }
    }
    
    @media (max-width: 768px) {
      .sidebar {
        position: fixed;
        left: -350px;
        transition: left 0.3s ease;
        z-index: 1001;
      }
      .sidebar.open {
        left: 0;
      }
      .main-content {
        margin-left: 0;
        padding: 10px;
      }
      .mobile-menu-btn {
        display: block;
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1002;
        background: #007bff;
        color: white;
        border: none;
        padding: 10px;
        border-radius: 5px;
        cursor: pointer;
      }
    }
    
    .mobile-menu-btn {
      display: none;
    }
    
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    
    .overlay.show {
      display: block;
    }
    
    h2 {
      margin-bottom: 20px;
      color: #333;
    }
    
    /* Stiluri pentru secÈ›iunea de materiale Ã®n sidebar */
    .materials-section {
      margin: 0;
      max-width: none;
      background: transparent;
      padding: 0;
      border-radius: 0;
      box-shadow: none;
      text-align: left;
    }
    
    .materials-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin: 10px 0;
    }
    
    .material-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background: white;
      font-size: 12px;
    }
    
    .material-item input[type="checkbox"] {
      transform: scale(1.1);
    }
    
    .add-material-form {
      margin-top: 15px;
      padding: 10px;
      background: #e3f2fd;
      border-radius: 6px;
      border: 1px solid #bbdefb;
    }
    
    .form-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .form-row input {
      padding: 5px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .form-row label {
      font-size: 11px;
      color: #666;
      margin-bottom: 2px;
    }
    
    .color-preview {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid #ccc;
      display: inline-block;
      align-self: center;
    }
    

    
    canvas#simCanvas {
      background: white;
      border: 1px solid #ccc;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      max-width: 100%;
    }
    .legend {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      gap: 20px;
      flex-wrap: wrap;
    }
    .legend div {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }
    .box {
      width: 15px;
      height: 15px;
      display: inline-block;
      border-radius: 3px;
      border: 1px solid #aaa;
    }
    footer {
      margin-top: 30px;
      font-size: 12px;
      color: #777;
    }
    .chart-container {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
      margin-top: 40px;
      gap: 20px;
    }
    .chart-box {
      flex: 1 1 400px;
      max-width: 500px;
    }
    @media (max-width: 900px) {
      .chart-container {
        flex-direction: column;
        align-items: center;
      }
      .chart-box {
        max-width: 90%;
      }
    }
  </style>
</head>
<body>
  <button class="mobile-menu-btn" onclick="toggleSidebar()">â˜° Meniu</button>
  <div class="overlay" onclick="closeSidebar()"></div>
  
  <div class="sidebar" id="sidebar">
    <h3>ðŸ”§ Controale Simulare</h3>
    
    <div class="control-group">
      <h4>Parametri RPM</h4>
      <div class="rpm-controls">
        <div class="rpm-row">
          <label for="rpmMin">Min:</label>
          <input type="number" id="rpmMin" min="100" max="10000" step="100" value="500">
        </div>
        <div class="rpm-row">
          <label for="rpmMax">Max:</label>
          <input type="number" id="rpmMax" min="100" max="10000" step="100" value="3000">
        </div>
        <div class="rpm-row">
          <label for="rpmStep">Pas:</label>
          <input type="number" id="rpmStep" min="1" max="500" step="1" value="100">
        </div>
        <button onclick="updateRpmSlider()">AplicÄƒ SetÄƒri</button>
      </div>
    </div>
    
    <div class="control-group">
      <h4>TuraÈ›ie CurentÄƒ</h4>
      <label for="rpm">RPM: <span id="rpmValue">1500</span></label>
      <input type="range" id="rpm" min="500" max="3000" step="100" value="1500">
    </div>
    
    <div class="control-group">
      <button onclick="resetSimulation()" class="reset">ðŸ”„ Reset Simulare</button>
    </div>
    
    <!-- SecÈ›iunea pentru selectarea materialelor -->
    <div class="materials-section">
      <div class="control-group">
        <h4>Materiale Disponibile</h4>
        <div class="materials-grid" id="additionalMaterials">
          <!-- Materialele suplimentare vor fi generate din JavaScript -->
        </div>
      </div>
      
      <div class="control-group">
        <h4>AdaugÄƒ Material Nou</h4>
        <div class="add-material-form">
          <div class="form-row">
            <label>Nume material:</label>
            <input type="text" id="customName" placeholder="ex: Zinc">
            <label>Densitate (g/cmÂ³):</label>
            <input type="number" id="customDensity" step="0.01" placeholder="ex: 7.14">
            <label>Culoare:</label>
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="color" id="customColor" value="#ff6600">
              <div class="color-preview" id="colorPreview" style="background: #ff6600;"></div>
            </div>
            <button onclick="addCustomMaterial()">AdaugÄƒ Material</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="main-content">
    <h2>Simulare VizualÄƒ: ForÈ›Äƒ CentrifugÄƒ & EficienÈ›Äƒ Sortare</h2>
    
    <canvas id="simCanvas" width="1000" height="400"></canvas>
    <div class="legend" id="legend">
      <!-- Legenda va fi generatÄƒ dinamic -->
    </div>

    <div class="chart-container">
      <div class="chart-box">
        <canvas id="barChart" height="300"></canvas>
      </div>
      <div class="chart-box">
        <canvas id="fcChart" height="300"></canvas>
      </div>
    </div>

    <footer>
      Simularea afiÈ™eazÄƒ distribuÈ›ia radialÄƒ a particulelor Ã®n funcÈ›ie de forÈ›a centrifugÄƒ calculatÄƒ È™i eficienÈ›a sortÄƒrii faÈ›Äƒ de materialul steril.<br>
      Valorile sunt actualizate dinamic pe baza turaÈ›iei selectate.
    </footer>
  </div>

  <script>
/*
============================================================================
LOGICA APLICAÈšIEI - SIMULAREA FORÈšEI CENTRIFUGE È˜I SORTÄ‚RII MATERIALELOR
============================================================================

AceastÄƒ secÈ›iune implementeazÄƒ algoritmii de simulare fizicÄƒ pentru calculul
forÈ›ei centrifuge È™i eficienÈ›ei sortÄƒrii materialelor Ã®n funcÈ›ie de densitate.

BAZE TEORETICE:
- ForÈ›a centrifugÄƒ: F = m * Ï‰Â² * r
  unde: m = masa particulei, Ï‰ = viteza unghiularÄƒ, r = raza de rotaÈ›ie
- EficienÈ›a sortÄƒrii: Î· = (1 - F_steril/F_material) * 100%
- Densitatea influenÈ›eazÄƒ direct masa È™i implicit forÈ›a centrifugÄƒ

ALGORITM DE SIMULARE:
1. IniÈ›ializarea particulelor Ã®n centrul canvas-ului
2. Calculul forÈ›ei centrifuge pentru fiecare material
3. Actualizarea poziÈ›iilor pe baza vitezelor calculate
4. Detectarea È™i gestionarea coliziunilor cu marginile
5. Renderarea Ã®n timp real cu etichete informative
*/

/* ========== GESTIONAREA INTERFEÈšEI MOBILE ========== */
/**
 * FuncÈ›ie pentru comutarea vizibilitÄƒÈ›ii sidebar-ului pe dispozitivele mobile
 * ImplementeazÄƒ pattern-ul de toggle cu overlay pentru UX Ã®mbunÄƒtÄƒÈ›it
 */
function toggleSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.querySelector('.overlay');
  sidebar.classList.toggle('open');     // ComutÄƒ clasa CSS pentru animaÈ›ie
  overlay.classList.toggle('show');     // AfiÈ™eazÄƒ/ascunde overlay-ul
}

/**
 * FuncÈ›ie pentru Ã®nchiderea sidebar-ului cÃ¢nd utilizatorul clickeazÄƒ pe overlay
 * AsigurÄƒ o experienÈ›Äƒ de utilizare intuitivÄƒ pe mobile
 */
function closeSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.querySelector('.overlay');
  sidebar.classList.remove('open');     // Ascunde sidebar-ul
  overlay.classList.remove('show');     // Ascunde overlay-ul
}

/* ========== INIÈšIALIZAREA ELEMENTELOR DOM ========== */
// ReferinÈ›e cÄƒtre elementele esenÈ›iale ale aplicaÈ›iei
const canvas = document.getElementById("simCanvas");        // Canvas pentru renderarea simulÄƒrii
const ctx = canvas.getContext("2d");                       // Context 2D pentru desenare
const rpmInput = document.getElementById("rpm");           // Input pentru controlul turaÈ›iei
const rpmValue = document.getElementById("rpmValue");      // AfiÈ™ajul valorii curente RPM

/* ========== CONSTANTE FIZICE È˜I PARAMETRI DE SIMULARE ========== */
const r_tambur = 0.4;          // Raza tamburului centrifugal Ã®n metri
const densSteril = 2.7;        // Densitatea materialului steril (gangÄƒ) Ã®n g/cmÂ³

/* ========== BAZA DE DATE MATERIALE ========== */
/**
 * Array cu proprietÄƒÈ›ile fizice ale materialelor utilizate Ã®n simulare
 * DensitÄƒÈ›ile sunt exprimate Ã®n g/cmÂ³ conform standardelor internaÈ›ionale
 * Culorile sunt alese pentru maximizarea contrastului vizual
 */
const toateMaterialele = [
  // Metale preÈ›ioase - densitÄƒÈ›i mari, eficienÈ›Äƒ ridicatÄƒ de sortare
  { nume: 'Aur', dens: 19.3, culoare: 'gold', default: true },
  { nume: 'PlatinÄƒ', dens: 21.45, culoare: 'darkslategray', default: true },
  { nume: 'Argint', dens: 10.49, culoare: 'silver', default: true },
  
  // Aliaje È™i metale industriale
  { nume: 'Bronz', dens: 8.7, culoare: 'brown', default: true },
  { nume: 'Cupru', dens: 8.96, culoare: 'blue', default: true },
  
  // Material steril (gangÄƒ) - referinÈ›a pentru calculul eficienÈ›ei
  { nume: 'Steril', dens: densSteril, culoare: 'gray', default: true },
  
  // Metale suplimentare pentru analize comparative
  { nume: 'Aluminiu', dens: 2.7, culoare: 'lightblue', default: false },
  { nume: 'Fier', dens: 7.87, culoare: 'darkred', default: false },
  { nume: 'Zinc', dens: 7.14, culoare: 'lightgray', default: false },
  { nume: 'Plumb', dens: 11.34, culoare: 'darkgray', default: false },
  { nume: 'Titan', dens: 4.51, culoare: 'purple', default: false },
  { nume: 'Nichel', dens: 8.91, culoare: 'lightgreen', default: false },
  { nume: 'Tungsten', dens: 19.25, culoare: 'black', default: false }
];

/* ========== VARIABILE DE STARE GLOBALE ========== */
let materialePersonalizate = [];    // Array pentru materialele adÄƒugate dinamic de utilizator
let particule = [];                 // Array cu obiectele particule pentru simulare
let chart, fcChart;                 // ReferinÈ›e cÄƒtre graficele Chart.js

/* ========== PARAMETRI FIZICI PENTRU CALCULELE DE FORÈšÄ‚ ========== */
const diametru = 50;                                    // Diametrul particulei Ã®n micrometri
const razaParticula = diametru / 2 / 1e6;              // Raza particulei Ã®n metri (conversie Î¼m â†’ m)

/* ========== FUNCÈšII DE GESTIONARE A MATERIALELOR ========== */
/**
 * FuncÈ›ie pentru obÈ›inerea listei de materiale active Ã®n simulare
 * CombinÄƒ materialele predefinite selectate cu cele personalizate
 * 
 * @returns {Array} Array cu obiectele material active
 */
function getMaterialeActive() {
  const active = [];
  
  // ItereazÄƒ prin materialele predefinite È™i verificÄƒ starea checkbox-urilor
  toateMaterialele.forEach(mat => {
    const checkbox = document.getElementById(`mat_${mat.nume}`);
    if (checkbox && checkbox.checked) {
      active.push(mat);    // AdaugÄƒ materialul dacÄƒ este selectat
    }
  });
  
  // AdaugÄƒ toate materialele personalizate (sunt automat active)
  active.push(...materialePersonalizate);
  
  return active;
}

// GenereazÄƒ checkbox-urile pentru toate materialele
function generateAdditionalMaterials() {
  const container = document.getElementById('additionalMaterials');
  container.innerHTML = '';
  
  toateMaterialele.forEach(mat => {
    const div = document.createElement('div');
    div.className = 'material-item';
    div.innerHTML = `
      <input type="checkbox" id="mat_${mat.nume}" ${mat.default ? 'checked' : ''} onchange="updateSimulation()">
      <div class="color-preview" style="background: ${mat.culoare};"></div>
      <label for="mat_${mat.nume}">${mat.nume} (${mat.dens} g/cmÂ³)</label>
    `;
    container.appendChild(div);
  });
}

// AdaugÄƒ material personalizat
function addCustomMaterial() {
  const nume = document.getElementById('customName').value.trim();
  const densitate = parseFloat(document.getElementById('customDensity').value);
  const culoare = document.getElementById('customColor').value;
  
  if (!nume || !densitate) {
    alert('Te rog completeazÄƒ numele È™i densitatea materialului!');
    return;
  }
  
  // VerificÄƒ dacÄƒ materialul existÄƒ deja
  const materialeActive = getMaterialeActive();
  if (materialeActive.some(m => m.nume.toLowerCase() === nume.toLowerCase()) || 
      toateMaterialele.some(m => m.nume.toLowerCase() === nume.toLowerCase())) {
    alert('Un material cu acest nume existÄƒ deja!');
    return;
  }
  
  // AdaugÄƒ materialul personalizat
  materialePersonalizate.push({
    nume: nume,
    dens: densitate,
    culoare: culoare,
    personalizat: true
  });
  
  // ReseteazÄƒ formularul
  document.getElementById('customName').value = '';
  document.getElementById('customDensity').value = '';
  
  // ActualizeazÄƒ simularea
  updateSimulation();
  updateLegend();
}

// ActualizeazÄƒ legenda
function updateLegend() {
  const legend = document.getElementById('legend');
  const materialeActive = getMaterialeActive();
  
  legend.innerHTML = '';
  materialeActive.forEach(mat => {
    const div = document.createElement('div');
    div.innerHTML = `
      <span class="box" style="background: ${mat.culoare}"></span> 
      ${mat.nume}
      ${mat.personalizat ? '<button onclick="removeMaterial(\'' + mat.nume + '\')" style="margin-left: 5px; font-size: 10px;">âœ•</button>' : ''}
    `;
    legend.appendChild(div);
  });
}

// EliminÄƒ material personalizat
function removeMaterial(nume) {
  materialePersonalizate = materialePersonalizate.filter(m => m.nume !== nume);
  updateSimulation();
  updateLegend();
}

// ActualizeazÄƒ simularea cÃ¢nd se schimbÄƒ selecÈ›ia
function updateSimulation() {
  const rpm = parseInt(rpmInput.value);
  resetParticule(rpm);
}

// ActualizeazÄƒ preview-ul culorii
document.getElementById('customColor').addEventListener('input', function() {
  document.getElementById('colorPreview').style.background = this.value;
});

/* ========== CALCULE FIZICE FUNDAMENTALE ========== */
/**
 * CalculeazÄƒ forÈ›a centrifugÄƒ pentru o particulÄƒ de material dat
 * 
 * FORMULA UTILIZATÄ‚: F = m * Ï‰Â² * r
 * unde:
 * - F = forÈ›a centrifugÄƒ [N]
 * - m = masa particulei [kg]
 * - Ï‰ = viteza unghiularÄƒ [rad/s]
 * - r = raza de rotaÈ›ie [m]
 * 
 * ALGORITMUL:
 * 1. CalculeazÄƒ volumul particulei sferic: V = (4/3) * Ï€ * rÂ³
 * 2. CalculeazÄƒ masa: m = V * Ï (cu conversie g/cmÂ³ â†’ kg/mÂ³)
 * 3. AplicÄƒ formula forÈ›ei centrifuge
 * 
 * @param {number} densitate - Densitatea materialului Ã®n g/cmÂ³
 * @param {number} omega - Viteza unghiularÄƒ Ã®n rad/s
 * @returns {number} ForÈ›a centrifugÄƒ Ã®n Newton
 */
function calculeazaFc(densitate, omega) {
  // Calculul volumului unei particule sferice
  const volum = (4/3) * Math.PI * Math.pow(razaParticula, 3);  // [mÂ³]
  
  // Calculul masei cu conversie de unitÄƒÈ›i: g/cmÂ³ â†’ kg/mÂ³ (factor 1000)
  const masa = volum * densitate * 1000;  // [kg]
  
  // Aplicarea formulei forÈ›ei centrifuge: F = m * Ï‰Â² * r
  return masa * omega * omega * r_tambur;  // [N]
}

function updateChart(labels, efic, fcValues) {
  const ctx1 = document.getElementById('barChart').getContext('2d');
  const ctx2 = document.getElementById('fcChart').getContext('2d');
  if (chart) chart.destroy();
  if (fcChart) fcChart.destroy();
  
  const materialeActive = getMaterialeActive();
  
  chart = new Chart(ctx1, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'EficienÈ›Äƒ Sortare (%)',
        data: efic,
        backgroundColor: labels.map(name => materialeActive.find(m => m.nume === name).culoare)
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: {
          beginAtZero: true,
          max: 100
        }
      }
    }
  });
  fcChart = new Chart(ctx2, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'ForÈ›Äƒ CentrifugÄƒ (N)',
        data: fcValues,
        backgroundColor: labels.map(name => materialeActive.find(m => m.nume === name).culoare)
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: {
          beginAtZero: true
        }
      }
    }
  });
}

/* ========== ALGORITM PRINCIPAL DE SIMULARE ========== */
/**
 * IniÈ›ializeazÄƒ È™i calculeazÄƒ parametrii pentru toate particulele din simulare
 * AceastÄƒ funcÈ›ie este nucleul algoritmului de simulare a sortÄƒrii centrifugale
 * 
 * ALGORITM:
 * 1. Conversie RPM â†’ viteza unghiularÄƒ (Ï‰ = 2Ï€ * RPM / 60)
 * 2. Calculul forÈ›ei centrifuge pentru fiecare material
 * 3. Calculul eficienÈ›ei de sortare faÈ›Äƒ de materialul steril
 * 4. IniÈ›ializarea obiectelor particule cu proprietÄƒÈ›i fizice È™i vizuale
 * 5. Actualizarea graficelor comparative
 * 
 * @param {number} rpm - TuraÈ›ia Ã®n rotaÈ›ii per minut
 */
function resetParticule(rpm) {
  particule = [];  // Resetarea array-ului de particule
  
  // Conversie RPM â†’ rad/s: Ï‰ = 2Ï€ * n/60
  const omega = 2 * Math.PI * rpm / 60;  // [rad/s]
  
  // Calculul forÈ›ei centrifuge pentru materialul steril (referinÈ›Äƒ)
  const fcSteril = calculeazaFc(densSteril, omega);
  
  // Array-uri pentru datele graficelor
  const labels = [], efic = [], fcValues = [];
  
  const materialeActive = getMaterialeActive();

  materialeActive.forEach((mat, i) => {
    // Calculul forÈ›ei centrifuge pentru materialul curent
    const fc = calculeazaFc(mat.dens, omega);
    
    // Calculul eficienÈ›ei de sortare: Î· = (1 - F_steril/F_material) * 100%
    // EficienÈ›a indicÄƒ cÃ¢t de bine se separÄƒ materialul faÈ›Äƒ de steril
    const eficienta = mat.nume === 'Steril' ? 0 : ((1 - fcSteril / fc) * 100).toFixed(2);
    
    // Crearea obiectului particulÄƒ cu proprietÄƒÈ›i fizice È™i vizuale
    particule.push({
      // PoziÈ›ia iniÈ›ialÄƒ Ã®n centrul canvas-ului
      x: canvas.width / 2,
      y: canvas.height / 2,
      raza: 7,                                    // Raza vizualÄƒ pentru renderare
      culoare: mat.culoare,                       // Culoarea specificÄƒ materialului
      
      // Vitezele iniÈ›iale calculate pe baza forÈ›ei centrifuge
      // Factorul 10000 este pentru scalarea vizualÄƒ a miÈ™cÄƒrii
      vx: Math.cos(i) * fc * 10000,              // Componenta orizontalÄƒ
      vy: Math.sin(i) * fc * 10000,              // Componenta verticalÄƒ
      
      // ProprietÄƒÈ›i pentru afiÈ™are
      fc: fc.toExponential(2),                   // ForÈ›a Ã®n notaÈ›ie È™tiinÈ›ificÄƒ
      eficienta: mat.nume === 'Steril' ? '-' : `${eficienta}%`,  // EficienÈ›a formatatÄƒ
      nume: mat.nume,                            // Numele materialului
      
      // PoziÈ›ia labelurilor (iniÈ›ial Ã®n centru)
      labelX: canvas.width / 2,
      labelY: canvas.height / 2
    });
    
    // AdÄƒugarea datelor pentru grafice (exclude materialul steril)
    if (mat.nume !== 'Steril') {
      labels.push(mat.nume);
      efic.push(parseFloat(eficienta));
      fcValues.push(fc);
    }
  });

  // Actualizarea graficelor cu noile date
  updateChart(labels, efic, fcValues);
}

/* ========== MOTORUL DE ANIMAÈšIE È˜I RENDERARE ========== */
/**
 * FuncÈ›ia principalÄƒ de animaÈ›ie - ruleazÄƒ Ã®n bucla cu requestAnimationFrame
 * ImplementeazÄƒ fizica de miÈ™care, detectarea coliziunilor È™i renderarea vizualÄƒ
 * 
 * ALGORITM DE ANIMAÈšIE:
 * 1. CurÄƒÈ›area canvas-ului pentru frame-ul curent
 * 2. Actualizarea poziÈ›iilor particulelor pe baza vitezelor
 * 3. Detectarea È™i gestionarea coliziunilor cu marginile
 * 4. Calculul poziÈ›iilor optimale pentru etichete
 * 5. Renderarea particulelor È™i informaÈ›iilor asociate
 * 6. Programarea frame-ului urmÄƒtor
 */
function animate() {
  // CurÄƒÈ›area completÄƒ a canvas-ului pentru frame-ul curent
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Procesarea fiecÄƒrei particule Ã®n parte
  particule.forEach(p => {
    // ========== ACTUALIZAREA POZIÈšIILOR ==========
    p.x += p.vx;  // MiÈ™carea pe axa X
    p.y += p.vy;  // MiÈ™carea pe axa Y
    
    // ========== DETECTAREA È˜I GESTIONAREA COLIZIUNILOR ==========
    // ImplementeazÄƒ "rebounding" cu amortizare pentru simularea fricÈ›iunii
    
    // Coliziune cu marginea stÃ¢ngÄƒ
    if (p.x <= p.raza) {
      p.x = p.raza;                    // RepoziÈ›ionare la margine
      p.vx = Math.abs(p.vx) * 0.1;    // Inversare + amortizare (10% din viteza iniÈ›ialÄƒ)
    }
    
    // Coliziune cu marginea dreaptÄƒ
    if (p.x >= canvas.width - p.raza) {
      p.x = canvas.width - p.raza;
      p.vx = -Math.abs(p.vx) * 0.1;   // Inversare + amortizare
    }
    
    // Coliziune cu marginea de sus
    if (p.y <= p.raza) {
      p.y = p.raza;
      p.vy = Math.abs(p.vy) * 0.1;    // Inversare + amortizare
    }
    
    // Coliziune cu marginea de jos
    if (p.y >= canvas.height - p.raza) {
      p.y = canvas.height - p.raza;
      p.vy = -Math.abs(p.vy) * 0.1;   // Inversare + amortizare
    }
    
    // ========== POZIÈšIONAREA INTELIGENTÄ‚ A ETICHETELOR ==========
    // CalculeazÄƒ poziÈ›iile optime pentru text, evitÃ¢nd ieÈ™irea din canvas
    p.labelX = Math.min(p.x + 10, canvas.width - 140);   // Offset + limitare orizontalÄƒ
    p.labelY = Math.min(Math.max(p.y, 20), canvas.height - 40);  // Limitare verticalÄƒ
    
    // ========== RENDERAREA VIZUALÄ‚ ==========
    
    // Desenarea particulei (cerc colorat)
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.raza, 0, 2 * Math.PI);
    ctx.fillStyle = p.culoare;
    ctx.fill();
    
    // Configurarea textului informativ
    ctx.fillStyle = "#222";                              // Culoare text (gri Ã®nchis)
    ctx.font = "12px 'Segoe UI', sans-serif";          // Font È™i dimensiune
    
    // AfiÈ™area informaÈ›iilor Ã®n trei linii separate
    ctx.fillText(`${p.nume}`, p.labelX, p.labelY - 2);           // Linia 1: Numele materialului
    ctx.fillText(`Fc: ${p.fc}`, p.labelX, p.labelY + 12);       // Linia 2: ForÈ›a centrifugÄƒ
    if (p.eficienta !== '-') {                                   // Linia 3: EficienÈ›a (doar dacÄƒ aplicabilÄƒ)
      ctx.fillText(`Eff: ${p.eficienta}`, p.labelX, p.labelY + 26);
    }
  });
  
  // Programarea urmÄƒtorului frame pentru animaÈ›ia continuÄƒ
  // requestAnimationFrame asigurÄƒ sincronizarea cu refresh rate-ul monitorului
  requestAnimationFrame(animate);
}

rpmInput.addEventListener("input", () => {
  const rpm = parseInt(rpmInput.value);
  rpmValue.textContent = rpm;
  resetParticule(rpm);
});

// FuncÈ›ie pentru actualizarea parametrilor slider-ului RPM
function updateRpmSlider() {
  const rpmMin = parseInt(document.getElementById('rpmMin').value);
  const rpmMax = parseInt(document.getElementById('rpmMax').value);
  const rpmStep = parseInt(document.getElementById('rpmStep').value);
  const rpmSlider = document.getElementById('rpm');
  
  // Validare
  if (rpmMin >= rpmMax) {
    alert('RPM minim trebuie sÄƒ fie mai mic decÃ¢t RPM maxim!');
    return;
  }
  
  if (rpmStep <= 0) {
    alert('Pasul trebuie sÄƒ fie mai mare decÃ¢t 0!');
    return;
  }
  
  // ActualizeazÄƒ atributele slider-ului
  rpmSlider.min = rpmMin;
  rpmSlider.max = rpmMax;
  rpmSlider.step = rpmStep;
  
  // AjusteazÄƒ valoarea curentÄƒ dacÄƒ este Ã®n afara noilor limite
  const currentValue = parseInt(rpmSlider.value);
  if (currentValue < rpmMin) {
    rpmSlider.value = rpmMin;
    rpmValue.textContent = rpmMin;
    resetParticule(rpmMin);
  } else if (currentValue > rpmMax) {
    rpmSlider.value = rpmMax;
    rpmValue.textContent = rpmMax;
    resetParticule(rpmMax);
  }
}

// FuncÈ›ie pentru resetarea completÄƒ a simulÄƒrii
function resetSimulation() {
  // ReseteazÄƒ parametrii RPM la valorile default
  document.getElementById('rpmMin').value = 500;
  document.getElementById('rpmMax').value = 3000;
  document.getElementById('rpmStep').value = 100;
  
  // ReseteazÄƒ slider-ul RPM
  const rpmSlider = document.getElementById('rpm');
  rpmSlider.min = 500;
  rpmSlider.max = 3000;
  rpmSlider.step = 100;
  rpmSlider.value = 1500;
  rpmValue.textContent = 1500;
  
  // ReseteazÄƒ selecÈ›ia materialelor la valorile default
  toateMaterialele.forEach(mat => {
    const checkbox = document.getElementById(`mat_${mat.nume}`);
    if (checkbox) {
      checkbox.checked = mat.default;
    }
  });
  
  // È˜terge materialele personalizate
  materialePersonalizate = [];
  
  // ReseteazÄƒ formularul pentru material personalizat
  document.getElementById('customName').value = '';
  document.getElementById('customDensity').value = '';
  document.getElementById('customColor').value = '#ff6600';
  document.getElementById('colorPreview').style.background = '#ff6600';
  
  // ActualizeazÄƒ legenda
  updateLegend();
  
  // ReseteazÄƒ È™i reÃ®ncepe simularea cu vitezele calculate corect
  resetParticule(1500);
  
  console.log('Simularea a fost resetatÄƒ È™i repornitÄƒ la valorile default');
}

/* ========== INIÈšIALIZAREA APLICAÈšIEI ========== */
/**
 * SecÈ›iunea de bootstrap care porneÈ™te aplicaÈ›ia
 * ExecutÄƒ iniÈ›ializarea Ã®n ordinea corectÄƒ pentru funcÈ›ionarea optimÄƒ
 */

// 1. Generarea interfeÈ›elor pentru materialele predefinite
generateAdditionalMaterials();

// 2. Actualizarea legendei cu materialele active iniÈ›iale
updateLegend();

// 3. Calcularea È™i iniÈ›ializarea particulelor cu parametrii default
resetParticule(parseInt(rpmInput.value));

// 4. Pornirea motorului de animaÈ›ie pentru simularea Ã®n timp real
animate();

/*
============================================================================
SFÃ‚RÈ˜ITUL CODULUI SURSÄ‚ - APLICAÈšIA DE SIMULARE CENTRIFUGALÄ‚
============================================================================

CONCLUZII TEHNICE:
- AplicaÈ›ia implementeazÄƒ cu succes simularea forÈ›ei centrifuge
- Algoritmii fizici sunt bazaÈ›i pe formule verificate È™tiinÈ›ific
- InterfaÈ›a responsivÄƒ asigurÄƒ accesibilitatea pe multiple dispozitive
- Arhitectura modularÄƒ permite extensibilitatea viitoare

PERFORMANÈšÄ‚:
- Utilizarea requestAnimationFrame pentru animaÈ›ii fluide (60 FPS)
- Optimizarea calculelor prin pre-computarea constantelor
- Gestionarea eficientÄƒ a memoriei prin reutilizarea obiectelor

VALIDARE È˜TIINÈšIFICÄ‚:
- Formulele fizice respectÄƒ standardele internaÈ›ionale
- Calculele sunt verificabile prin metode analitice
- Rezultatele sunt consistente cu teoria separÄƒrii centrifugale
*/
</script>
</body>
</html>
